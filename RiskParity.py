# -*- coding: utf-8 -*-
"""PS2_406306460.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bLlBYTLYgAbhIWT6qS9JRFo469Gwv99k
"""

import warnings
warnings.filterwarnings('ignore')

!pip install wrds

!pip install --upgrade numpy scipy

"""# Problem Set 2: Risk Parity

## Loading Data and other Pre-requisites
"""

# importing the required libraries

import os
import pandas as pd
import numpy as np
import wrds
from random import *
from dateutil.relativedelta import *
from pandas.tseries.offsets import *
import scipy.stats
import matplotlib.pyplot as plt
import datetime
import pandas_datareader

# connecting with the wrds account
conn = wrds.Connection(wrds_username="vrai")

#--- Using the code shared by Prof. Herskovic for data upload ---

# LOADING CRSP DATA FROM WRDS -- Bonds data
print('Load Bond Data')
bonds = conn.raw_sql("""
                      select kycrspid, mcaldt, tmretnua, tmtotout
                      from crspq.tfz_mth
                      """)
bonds['mcaldt']   = pd.DataFrame(bonds[['mcaldt']].values.astype('datetime64[ns]')) + MonthEnd(0)
bonds = bonds.rename(columns={"mcaldt":"date","tmretnua":"ret","tmtotout":"me","kycrspid":"idCRSP"}).copy()

# LOADING CRSP DATA FROM WRDS -- T-Bill data
print('Load T-Bill Data')
rf = conn.raw_sql("""
                      select caldt, t30ret, t90ret
                      from crspq.mcti
                      """)
rf['caldt']   = pd.DataFrame(rf[['caldt']].values.astype('datetime64[ns]')) + MonthEnd(0)
rf = rf.rename(columns={"caldt":"date","t30ret":"rf30","t90ret":"rf90"}).copy()

# LOADING CRSP DATA FROM WRDS -- Equity Returns
print('Load Equity Returns Data')
crsp_raw = conn.raw_sql("""
    select a.permno, a.permco, a.date, b.shrcd, b.exchcd,
    a.ret, a.retx, a.shrout, a.prc, a.cfacshr, a.cfacpr
    from crspq.msf as a
    left join crsp.msenames as b
    on a.permno=b.permno
    and b.namedt<=a.date
    and a.date<=b.nameendt
    where a.date between '01/01/1900' and '12/31/2023'
""")

crsp_raw = crsp_raw.sort_values(['permno', 'date']).reset_index(drop=True).copy()
crsp_raw['permno'] = crsp_raw['permno'].astype(int)
crsp_raw['permco'] = crsp_raw['permco'].astype(int)
crsp_raw['date'] = pd.to_datetime(crsp_raw['date'], format='%Y-%m-%d', errors='ignore') + MonthEnd(0)

# LOADING CRSP DATA FROM WRDS -- Deilsting Returns
print('Load Delisting Returns Data')
dlret_raw = conn.raw_sql("""
    select permno, dlret, dlstdt, dlstcd
    from crspq.msedelist
""")
dlret_raw = dlret_raw.sort_values(['permno', 'dlstdt']).reset_index(drop=True).copy()
dlret_raw.permno = dlret_raw.permno.astype(int)
dlret_raw['dlstdt'] = pd.to_datetime(dlret_raw['dlstdt'])
dlret_raw['date'] = dlret_raw['dlstdt'] + MonthEnd(0)

# LOADING CRSP DATA FROM WRDS -- CRSP VW market index (for comparison purposes)
print('Load VW CRSP market index Data')
mkt_csrp = conn.raw_sql("""
                      select date, VWRETD, totval
                      from crspq.msi
                      """)
mkt_csrp['date']   = pd.DataFrame(mkt_csrp[['date']].values.astype('datetime64[ns]')) + MonthEnd(0)
mkt_csrp = mkt_csrp.rename(columns={"vwretd":"mkt_crsp","totval":"mkt_crsp_mktcap"}).copy()

# Close connection to WRDS
conn.close()

# merging the delisted returns with the original returns in crsp data
crsp_dlret_merged = pd.merge(crsp_raw, dlret_raw[['permno', 'date', 'dlret']],
                             on=['permno', 'date'],
                             how='left')
crsp_dlret_merged['dlret'].fillna(0, inplace=True)

"""## Problem 1: Creating Bond Market Return Portfolios"""

def PS2_Q1(bonds):

  # dropping rows with NaN values in any of the columns of interest
  bonds = bonds.dropna(subset=['ret', 'me'])

  # creating year and month columns
  bonds['Year'] = bonds['date'].dt.year
  bonds['Month'] = bonds['date'].dt.month

  # calculating the lagged market value
  bonds['lagged_MV'] = bonds.groupby('idCRSP')['me'].shift(1)

  # creating an output of equally-weighted returns and value-weighted returns calculation
  results = bonds.groupby(['Year', 'Month']).agg(
      Bond_lag_MV=('lagged_MV', 'sum'),
      Bond_Ew_Ret=('ret', 'mean'),
      Bond_Vw_Ret=('ret', lambda x:
                    (x * bonds.loc[x.index, 'lagged_MV']).sum() /
                    bonds.loc[x.index, 'lagged_MV'].sum())
  ).reset_index()

  results = results[results['Year'] >= 1926]

  return results

output_q1 = PS2_Q1(bonds)
output_q1.head()

"""## Problem 2: Calculating Excess Returns for Bonds and Stocks"""

# reusing the PS1_Q1 function from the first problem set to get the Stock Value Weighted returns
def PS1_Q1(CRSP_Merged):

  # restricting the sample by EXCHCD and SHRCD
  CRSP_Merged = CRSP_Merged.set_index('permno')
  valid_exchcd = [-2, -1, 0, 1, 2, 3]  # NYSE, AMEX, NASDAQ
  valid_shrcd = [10, 11]  # Common shares
  CRSP_Merged = CRSP_Merged[(CRSP_Merged['exchcd'].isin(valid_exchcd)) & (CRSP_Merged['shrcd'].isin(valid_shrcd))]

  # calculating market cap column
  CRSP_Merged['MktCap'] = abs(CRSP_Merged['prc']) * CRSP_Merged['shrout']
  CRSP_Merged['Lag_MktCap'] = CRSP_Merged.groupby('permno')['MktCap'].shift(1)

  # replacing missing returns with 0
  CRSP_Merged['ret'] = CRSP_Merged['ret'].fillna(0)

  # Forward-fill missing prices and shares outstanding
  CRSP_Merged = CRSP_Merged.dropna(subset=['prc', 'shrout', 'ret'])

  # calculating cum-dividend returns
  CRSP_Merged['CumRet'] = (1 + CRSP_Merged['ret']) * (1 + CRSP_Merged['dlret']) - 1

  # calculating value-weighted and equal-weighted returns
  grouped = CRSP_Merged.groupby('date')
  vw_ret = grouped.apply(lambda x: np.sum(x['CumRet'] * x['Lag_MktCap']) / np.sum(x['Lag_MktCap']))
  ew_ret = grouped['CumRet'].mean()

  # combining the results into a single dataframe
  result = pd.DataFrame({ 'Stock_lag_MV': grouped['Lag_MktCap'].sum() / 1000,  # converting to millions
                          'Stock_Ew_Ret': ew_ret,
                          'Stock_Vw_Ret': vw_ret})

  return result

stocks = PS1_Q1(crsp_dlret_merged)
stocks.head()

def PS2_Q2(stocks, bonds, riskfree):

  # creating year and month columns for stocks and riskfree columns
  stocks['Year'] = stocks.index.year
  stocks['Month'] = stocks.index.month
  riskfree['Year'] = riskfree['date'].dt.year
  riskfree['Month'] = riskfree['date'].dt.month

  # merging the stocks and bonds dataframes on Year and Month
  combined = pd.merge(stocks.reset_index(), bonds, on=['Year', 'Month'], how='left', suffixes=('_Stock', '_Bond'))

  # merging the combined dataframe with the riskless rate dataframe on Year and Month
  combined = pd.merge(combined, riskfree, left_on=['Year', 'Month'], right_on=['Year', 'Month'], how='left')

  # calculating the excess value-weighted returns
  combined['Stock_Excess_Vw_Ret'] = combined['Stock_Vw_Ret'] - combined['rf30']
  combined['Bond_Excess_Vw_Ret'] = combined['Bond_Vw_Ret'] - combined['rf30']

  # structuring the final output in the required format
  results = combined[['Year', 'Month', 'Stock_lag_MV', 'Stock_Excess_Vw_Ret', 'Bond_lag_MV', 'Bond_Excess_Vw_Ret']]
  results = results[results['Year'] >= 1926]

  return results

output_q2 = PS2_Q2(stocks, output_q1, rf)
output_q2.head()

"""## Problem 3: Monthly Unlevered and Levered Risk-Parity Portfolio Returns"""

def PS2_Q3(Monthly_CRSP_Universe):

  # calculating the value-weighted portfolio return above riskless rate
  Monthly_CRSP_Universe['Excess_Vw_Ret'] = (Monthly_CRSP_Universe['Stock_lag_MV'] * Monthly_CRSP_Universe['Stock_Excess_Vw_Ret'] + \
                                            Monthly_CRSP_Universe['Bond_lag_MV'] * Monthly_CRSP_Universe['Bond_Excess_Vw_Ret']) / \
                                            (Monthly_CRSP_Universe['Stock_lag_MV'] + Monthly_CRSP_Universe['Bond_lag_MV'])

  # calculating the 60-40 portfolio return above riskless rate
  Monthly_CRSP_Universe['Excess_60_40_Ret'] = 0.6 * Monthly_CRSP_Universe['Stock_Excess_Vw_Ret'] + 0.4 * Monthly_CRSP_Universe['Bond_Excess_Vw_Ret']

  # calculating inverse volatility for stocks and bonds
  Monthly_CRSP_Universe['Stock_inverse_sigma_hat'] = 1 / Monthly_CRSP_Universe['Stock_Excess_Vw_Ret'].rolling(36).std().shift(1)
  Monthly_CRSP_Universe['Bond_inverse_sigma_hat'] = 1 / Monthly_CRSP_Universe['Bond_Excess_Vw_Ret'].rolling(36).std().shift(1)

  # calculating risk-parity weights
  Monthly_CRSP_Universe['Unlevered_k'] = 1 / (Monthly_CRSP_Universe['Stock_inverse_sigma_hat'] + Monthly_CRSP_Universe['Bond_inverse_sigma_hat'])

  # calculating unlevered risk-parity portfolio return above riskless rate
  Monthly_CRSP_Universe['Excess_Unlevered_RP_Ret'] = ((Monthly_CRSP_Universe['Unlevered_k'] * Monthly_CRSP_Universe['Stock_inverse_sigma_hat']) * Monthly_CRSP_Universe['Stock_Excess_Vw_Ret']) + \
                                                      ((Monthly_CRSP_Universe['Unlevered_k'] * Monthly_CRSP_Universe['Bond_inverse_sigma_hat']) * Monthly_CRSP_Universe['Bond_Excess_Vw_Ret'])

  # matching the standard deviation of the portfolio to the volatility of Excess_Vw_Ret
  Excess_Vw_Ret_sigma = Monthly_CRSP_Universe['Excess_Vw_Ret'].std()
  temp = Monthly_CRSP_Universe['Stock_inverse_sigma_hat'] * Monthly_CRSP_Universe['Stock_Excess_Vw_Ret'] + \
          Monthly_CRSP_Universe['Bond_inverse_sigma_hat'] * Monthly_CRSP_Universe['Bond_Excess_Vw_Ret']
  Monthly_CRSP_Universe['Levered_k'] = Excess_Vw_Ret_sigma / temp.std()

  # calculating levered risk-parity portfolio return above riskless rate
  Monthly_CRSP_Universe['Excess_Levered_RP_Ret'] = ((Monthly_CRSP_Universe['Levered_k'] * Monthly_CRSP_Universe['Stock_inverse_sigma_hat']) * Monthly_CRSP_Universe['Stock_Excess_Vw_Ret']) + \
                                                    ((Monthly_CRSP_Universe['Levered_k'] * Monthly_CRSP_Universe['Bond_inverse_sigma_hat']) * Monthly_CRSP_Universe['Bond_Excess_Vw_Ret'])

  # dropping initial 36 months with incomplete rolling window calculations
  output = Monthly_CRSP_Universe.iloc[36:].copy().reset_index(drop=True)

  # structuring the final output in the required format
  results = output[['Year', 'Month', 'Stock_Excess_Vw_Ret', 'Bond_Excess_Vw_Ret',
                          'Excess_Vw_Ret', 'Excess_60_40_Ret', 'Stock_inverse_sigma_hat',
                          'Bond_inverse_sigma_hat', 'Unlevered_k', 'Excess_Unlevered_RP_Ret',
                          'Levered_k', 'Excess_Levered_RP_Ret']]

  return results

Monthly_CRSP_Universe = output_q2.copy()
output_q3 = PS2_Q3(Monthly_CRSP_Universe)
output_q3.head()

"""## Problem 4: Historical Performance of the Risk Parity, Market, and 60/40 Portfolios"""

def PS2_Q4(Port_Rets):

  # filtering for the required date range mentioned in the question
  filtered_data = Port_Rets[(Port_Rets['Year'] >= 1929) & (Port_Rets['Year'] <= 2010)][:-6]

  ptf_returns = filtered_data[['Stock_Excess_Vw_Ret','Bond_Excess_Vw_Ret', 'Excess_Vw_Ret', 'Excess_60_40_Ret', 'Excess_Unlevered_RP_Ret', 'Excess_Levered_RP_Ret']]

  # calculating the annualized excess return, sharpe ratio and other moments
  annualized_excess_return = ptf_returns.mean() * 12
  annualized_volatility = ptf_returns.std() * np.sqrt(12)
  annualized_sharpe_ratio = annualized_excess_return / annualized_volatility
  skewness = ptf_returns.skew()
  excess_kurtosis = ptf_returns.kurtosis()

  # calculating t-statistic for the annualized excess return
  t_stat = np.sqrt(len(ptf_returns)) * ptf_returns.mean() / ptf_returns.std()

  # creating a summary DataFrame
  summary_stats = pd.DataFrame({
      'Excess Return': (annualized_excess_return * 100).round(2),
      't-stat': t_stat.round(2),
      'Volatility': (annualized_volatility * 100).round(2),
      'Sharpe Ratio': annualized_sharpe_ratio.round(2),
      'Skewness': skewness.round(2),
      'Excess Kurtosis': excess_kurtosis.round(2)
  })

  # structuring the final output in the required format
  portfolio_order = ['Stock_Excess_Vw_Ret', 'Bond_Excess_Vw_Ret', 'Excess_Vw_Ret', 'Excess_60_40_Ret',
                      'Excess_Unlevered_RP_Ret', 'Excess_Levered_RP_Ret']
  summary_stats = summary_stats.loc[portfolio_order]
  summary_stats.index = ['CRSP stocks', 'CRSP bonds', 'Value-weighted portfolio', '60/40 portfolio',
                          'RP, Unlevered', 'RP']

  return summary_stats

Port_Rets = output_q3.copy()
output_q4 = PS2_Q4(Port_Rets)
output_q4